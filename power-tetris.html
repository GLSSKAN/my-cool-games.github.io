<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>æŠ€èƒ½ä¿„ç½—æ–¯æ–¹å— (Power-Up Tetris)</title>
    <script src="https://cdn.tailwindcss.com"></script>
</head>
<body class="bg-gray-900 text-white font-sans flex flex-col items-center justify-center min-h-screen m-0">
    <div class="text-center mb-5">
        <h1 class="text-4xl font-bold mb-2">æŠ€èƒ½ä¿„ç½—æ–¯æ–¹å—</h1>
        <p class="text-xl">æ–¹å‘é”®æˆ–WASDç§»åŠ¨/æ—‹è½¬ï¼Œç©ºæ ¼é”®å¿«é€Ÿä¸‹è½</p>
    </div>

    <div class="flex gap-8 items-start">
        <!-- æ¸¸æˆä¸»åŒºåŸŸ -->
        <div id="game-container" class="relative border-4 border-green-600 bg-gray-800">
            <canvas id="game-canvas" class="block"></canvas>
            
            <!-- å¼€å§‹ç•Œé¢ -->
            <div id="start-screen" class="absolute inset-0 bg-black/70 flex flex-col items-center justify-center">
                <h2 class="text-3xl font-bold mb-6">æŠ€èƒ½ä¿„ç½—æ–¯æ–¹å—</h2>
                <p class="mb-2">æ–¹å‘é”®æˆ–WASDç§»åŠ¨/æ—‹è½¬ï¼Œç©ºæ ¼é”®å¿«é€Ÿä¸‹è½</p>
                <p class="mb-4">æŠ€èƒ½å¿«æ·é”®: 1(ç‚¸å¼¹), 2(å‡é€Ÿ), 3(å˜æ¢), 4(æ°´å¹³æ¶ˆé™¤), 5(ç²‰ç¢), 6(å¹½çµæ¨¡å¼), 7(é‡åŠ›åè½¬)</p>
                <p class="mb-6">æœ€é«˜è®°å½•: <span id="high-score-display">0</span></p>
                <button id="start-button" class="px-6 py-3 bg-green-600 text-white text-xl rounded hover:bg-green-700 transition-colors">
                    å¼€å§‹æ¸¸æˆ
                </button>
            </div>

            <!-- æ¸¸æˆç»“æŸç•Œé¢ -->
            <div id="game-over-screen" class="absolute inset-0 bg-black/70 flex flex-col items-center justify-center hidden">
                <h2 class="text-4xl font-bold text-red-500 mb-2">æ¸¸æˆç»“æŸ!</h2>
                <p class="text-2xl mb-2">ä½ çš„å¾—åˆ†: <span id="final-score">0</span></p>
                <p class="text-2xl mb-6">æœ€é«˜è®°å½•: <span id="final-high-score">0</span></p>
                <button id="restart-button" class="mt-6 px-6 py-3 bg-green-600 text-white text-xl rounded hover:bg-green-700 transition-colors">
                    å†æ¥ä¸€å±€
                </button>
            </div>
        </div>

        <!-- æ¸¸æˆä¿¡æ¯å’Œæ§åˆ¶é¢æ¿ -->
        <div class="flex flex-col gap-6">
            <!-- ä¸‹ä¸€ä¸ªæ–¹å—é¢„è§ˆ -->
            <div class="border-4 border-green-600 bg-gray-800 p-4">
                <h3 class="text-xl font-bold mb-2 text-center">ä¸‹ä¸€ä¸ª</h3>
                <canvas id="next-piece-canvas" class="block mx-auto"></canvas>
            </div>

            <!-- åˆ†æ•°å’Œç­‰çº§ -->
            <div class="bg-gray-800 p-4 rounded-lg border-2 border-green-600">
                <div class="text-xl mb-2">åˆ†æ•°: <span id="score" class="text-green-500">0</span></div>
                <div class="text-xl mb-2">æœ€é«˜è®°å½•: <span id="current-high-score" class="text-yellow-500">0</span></div>
                <div class="text-xl mb-2">ç­‰çº§: <span id="level" class="text-green-500">1</span></div>
                <div class="text-xl">å·²æ¶ˆé™¤è¡Œæ•°: <span id="lines" class="text-green-500">0</span></div>
            </div>

            <!-- æŠ€èƒ½ç³»ç»Ÿ -->
            <div class="bg-gray-800 p-4 rounded-lg border-2 border-green-600">
                <h3 class="text-xl font-bold mb-3 text-center">æŠ€èƒ½ç³»ç»Ÿ</h3>
                
                <!-- èƒ½é‡æ¡ -->
                <div class="mb-4">
                    <div class="flex justify-between mb-1">
                        <span>èƒ½é‡</span>
                        <span id="power-percentage">0%</span>
                    </div>
                    <div class="w-full bg-gray-700 rounded-full h-4 overflow-hidden">
                        <div id="power-bar" class="bg-yellow-500 h-full rounded-full w-0 transition-all duration-100"></div>
                    </div>
                </div>
                
                <!-- æŠ€èƒ½æ¬¡æ•° -->
                <div class="mb-4 text-center">
                    <span>æŠ€èƒ½æ¬¡æ•°: </span>
                    <span id="skill-count" class="text-yellow-500 font-bold">0</span>
                    <span>/3</span>
                </div>
                
                <!-- æŠ€èƒ½æŒ‰é’® -->
                <div class="grid grid-cols-1 gap-2">
                    <button id="skill-bomb" class="skill-button py-2 px-4 bg-red-600 text-white rounded disabled:bg-gray-600 disabled:cursor-not-allowed flex items-center justify-center gap-2" disabled>
                        <span>ğŸ’£ (1)</span> ç‚¸å¼¹ (æ¸…é™¤ä¸‰è¡Œ)
                    </button>
                    <button id="skill-slow" class="skill-button py-2 px-4 bg-blue-600 text-white rounded disabled:bg-gray-600 disabled:cursor-not-allowed flex items-center justify-center gap-2" disabled>
                        <span>â±ï¸ (2)</span> å‡é€Ÿ (10ç§’)
                    </button>
                    <button id="skill-transform" class="skill-button py-2 px-4 bg-purple-600 text-white rounded disabled:bg-gray-600 disabled:cursor-not-allowed flex items-center justify-center gap-2" disabled>
                        <span>ğŸ”„ (3)</span> å˜æ¢ (å½“å‰æ–¹å—)
                    </button>
                    <button id="skill-line-clear" class="skill-button py-2 px-4 bg-green-600 text-white rounded disabled:bg-gray-600 disabled:cursor-not-allowed flex items-center justify-center gap-2" disabled>
                        <span>ğŸ—¡ï¸ (4)</span> æ°´å¹³æ¶ˆé™¤ (å½“å‰è¡Œ)
                    </button>
                    <button id="skill-smash" class="skill-button py-2 px-4 bg-orange-600 text-white rounded disabled:bg-gray-600 disabled:cursor-not-allowed flex items-center justify-center gap-2" disabled>
                        <span>ğŸ”¨ (5)</span> ç²‰ç¢ (éšæœº12ä¸ªæ–¹å—)
                    </button>
                    <button id="skill-ghost" class="skill-button py-2 px-4 bg-indigo-600 text-white rounded disabled:bg-gray-600 disabled:cursor-not-allowed flex items-center justify-center gap-2" disabled>
                        <span>ğŸ‘» (6)</span> å¹½çµæ¨¡å¼ (5ç§’)
                    </button>
                    <button id="skill-gravity" class="skill-button py-2 px-4 bg-pink-600 text-white rounded disabled:bg-gray-600 disabled:cursor-not-allowed flex items-center justify-center gap-2" disabled>
                        <span>ğŸ”¼ (7)</span> é‡åŠ›åè½¬ (5ç§’)
                    </button>
                </div>
            </div>
        </div>
    </div>

    <script>
        // è·å–DOMå…ƒç´ 
        const gameCanvas = document.getElementById('game-canvas');
        const nextPieceCanvas = document.getElementById('next-piece-canvas');
        const ctx = gameCanvas.getContext('2d');
        const nextCtx = nextPieceCanvas.getContext('2d');
        const startScreen = document.getElementById('start-screen');
        const gameOverScreen = document.getElementById('game-over-screen');
        const startButton = document.getElementById('start-button');
        const restartButton = document.getElementById('restart-button');
        const scoreDisplay = document.getElementById('score');
        const levelDisplay = document.getElementById('level');
        const linesDisplay = document.getElementById('lines');
        const finalScoreDisplay = document.getElementById('final-score');
        const highScoreDisplay = document.getElementById('high-score-display');
        const currentHighScoreDisplay = document.getElementById('current-high-score');
        const finalHighScoreDisplay = document.getElementById('final-high-score');
        
        // æŠ€èƒ½ç³»ç»Ÿå…ƒç´ 
        const powerBar = document.getElementById('power-bar');
        const powerPercentage = document.getElementById('power-percentage');
        const skillButtons = document.querySelectorAll('.skill-button');
        const skillCountDisplay = document.getElementById('skill-count');
        const skillBombButton = document.getElementById('skill-bomb');
        const skillSlowButton = document.getElementById('skill-slow');
        const skillTransformButton = document.getElementById('skill-transform');
        const skillLineClearButton = document.getElementById('skill-line-clear');
        const skillSmashButton = document.getElementById('skill-smash');
        const skillGhostButton = document.getElementById('skill-ghost');
        const skillGravityButton = document.getElementById('skill-gravity');

        // æ¸¸æˆé…ç½®
        const GRID_WIDTH = 10;
        const GRID_HEIGHT = 20;
        const CELL_SIZE = 30;
        gameCanvas.width = GRID_WIDTH * CELL_SIZE;
        gameCanvas.height = GRID_HEIGHT * CELL_SIZE;
        
        // ä¸‹ä¸€ä¸ªæ–¹å—é¢„è§ˆç”»å¸ƒå¤§å° (ä»¥æœ€å¤§çš„æ–¹å— "I" ä¸ºåŸºå‡†)
        nextPieceCanvas.width = 4 * CELL_SIZE;
        nextPieceCanvas.height = 4 * CELL_SIZE;

        // æ–¹å—å½¢çŠ¶å®šä¹‰ (ç»å…¸ä¿„ç½—æ–¯æ–¹å—)
        const SHAPES = [
            { // I
                shape: [
                    [0, 0, 0, 0],
                    [1, 1, 1, 1],
                    [0, 0, 0, 0],
                    [0, 0, 0, 0]
                ],
                color: '#00f0f0' // Cyan
            },
            { // J
                shape: [
                    [1, 0, 0],
                    [1, 1, 1],
                    [0, 0, 0]
                ],
                color: '#0000f0' // Blue
            },
            { // L
                shape: [
                    [0, 0, 1],
                    [1, 1, 1],
                    [0, 0, 0]
                ],
                color: '#f0a000' // Orange
            },
            { // O
                shape: [
                    [1, 1],
                    [1, 1]
                ],
                color: '#f0f000' // Yellow
            },
            { // S
                shape: [
                    [0, 1, 1],
                    [1, 1, 0],
                    [0, 0, 0]
                ],
                color: '#00f000' // Green
            },
            { // T
                shape: [
                    [0, 1, 0],
                    [1, 1, 1],
                    [0, 0, 0]
                ],
                color: '#a000f0' // Purple
            },
            { // Z
                shape: [
                    [1, 1, 0],
                    [0, 1, 1],
                    [0, 0, 0]
                ],
                color: '#f00000' // Red
            }
        ];

        // æ¸¸æˆçŠ¶æ€
        let board = [];
        let currentPiece = null;
        let nextPiece = null;
        let score = 0;
        let highScore = localStorage.getItem('tetrisHighScore') ? parseInt(localStorage.getItem('tetrisHighScore')) : 0;
        let level = 1;
        let linesCleared = 0;
        let dropInterval = 1000; // åˆå§‹ä¸‹è½é€Ÿåº¦ (æ¯«ç§’)
        let dropTimer = null;
        let isGameRunning = false;
        let gameLoopId = null;
        
        // æŠ€èƒ½ç³»ç»ŸçŠ¶æ€
        let power = 0;
        const MAX_POWER = 100;
        const POWER_PER_LINE = 10; // æ¯æ¶ˆé™¤ä¸€è¡Œè·å¾—çš„èƒ½é‡
        let skillCharges = 0;
        const MAX_SKILL_CHARGES = 3;
        let isSlowActive = false;
        let slowTimer = null;
        let isGhostActive = false;
        let ghostTimer = null;
        let isGravityReversed = false;
        let gravityTimer = null;

        // æ›´æ–°æœ€é«˜åˆ†æ•°æ˜¾ç¤º
        function updateHighScoreDisplay() {
            highScoreDisplay.textContent = highScore;
            currentHighScoreDisplay.textContent = highScore;
            finalHighScoreDisplay.textContent = highScore;
        }

        // ä¿å­˜æœ€é«˜åˆ†æ•°åˆ°æœ¬åœ°å­˜å‚¨
        function saveHighScore() {
            if (score > highScore) {
                highScore = score;
                localStorage.setItem('tetrisHighScore', highScore.toString());
                updateHighScoreDisplay();
            }
        }

        // åˆå§‹åŒ–æ¸¸æˆåŒºåŸŸ
        function initBoard() {
            board = Array(GRID_HEIGHT).fill().map(() => Array(GRID_WIDTH).fill(0));
        }

        // éšæœºç”Ÿæˆä¸€ä¸ªæ–°æ–¹å—
        function generateRandomPiece() {
            const randomIndex = Math.floor(Math.random() * SHAPES.length);
            const piece = SHAPES[randomIndex];
            return {
                shape: JSON.parse(JSON.stringify(piece.shape)), // æ·±æ‹·è´ï¼Œé¿å…ä¿®æ”¹åŸæ•°ç»„
                color: piece.color,
                x: Math.floor((GRID_WIDTH - piece.shape[0].length) / 2),
                y: 0
            };
        }

        // æ£€æŸ¥ç§»åŠ¨æ˜¯å¦æœ‰æ•ˆ
        function isValidMove(piece, offsetX, offsetY) {
            for (let y = 0; y < piece.shape.length; y++) {
                for (let x = 0; x < piece.shape[y].length; x++) {
                    if (piece.shape[y][x]) {
                        const newX = piece.x + x + offsetX;
                        const newY = piece.y + y + offsetY;
                        
                        // æ£€æŸ¥æ˜¯å¦è¶…å‡ºè¾¹ç•Œ
                        if (newX < 0 || newX >= GRID_WIDTH || newY >= GRID_HEIGHT || newY < 0) {
                            return false;
                        }
                        
                        // æ£€æŸ¥æ˜¯å¦ä¸å·²æœ‰æ–¹å—ç¢°æ’
                        if (board[newY][newX]) {
                            return false;
                        }
                    }
                }
            }
            return true;
        }

        // æ—‹è½¬æ–¹å—
        function rotatePiece(piece) {
            const rotatedShape = [];
            for (let x = 0; x < piece.shape[0].length; x++) {
                const newRow = [];
                for (let y = piece.shape.length - 1; y >= 0; y--) {
                    newRow.push(piece.shape[y][x]);
                }
                rotatedShape.push(newRow);
            }
            
            const originalShape = piece.shape;
            piece.shape = rotatedShape;
            
            // å¦‚æœæ—‹è½¬åæ— æ•ˆï¼Œå°è¯•å¢™è¸¢ (wall kick)
            const wallKicks = [0, -1, 1, -2, 2]; // å°è¯•çš„æ°´å¹³åç§»é‡
            for (const kick of wallKicks) {
                if (isValidMove(piece, kick, 0)) {
                    piece.x += kick;
                    return;
                }
            }
            
            // å¦‚æœæ‰€æœ‰å¢™è¸¢éƒ½æ— æ•ˆï¼Œåˆ™å–æ¶ˆæ—‹è½¬
            piece.shape = originalShape;
        }

        // å°†å½“å‰æ–¹å—é”å®šåˆ°æ¸¸æˆåŒºåŸŸ
        function lockPiece() {
            for (let y = 0; y < currentPiece.shape.length; y++) {
                for (let x = 0; x < currentPiece.shape[y].length; x++) {
                    if (currentPiece.shape[y][x]) {
                        const boardY = currentPiece.y + y;
                        const boardX = currentPiece.x + x;
                        if (boardY >= 0) { // åªé”å®šåœ¨æ¸¸æˆåŒºåŸŸå†…çš„éƒ¨åˆ†
                            board[boardY][boardX] = currentPiece.color;
                        }
                    }
                }
            }
            
            // æ£€æŸ¥æ˜¯å¦æœ‰å¯ä»¥æ¶ˆé™¤çš„è¡Œ
            clearLines();
            
            // å‡†å¤‡ä¸‹ä¸€ä¸ªæ–¹å—
            currentPiece = nextPiece;
            nextPiece = generateRandomPiece();
            
            // æ£€æŸ¥æ¸¸æˆæ˜¯å¦ç»“æŸ (æ–°æ–¹å—æ— æ³•ç§»åŠ¨)
            if (!isValidMove(currentPiece, 0, 0)) {
                gameOver();
            }
            
            // æ¸²æŸ“ä¸‹ä¸€ä¸ªæ–¹å—é¢„è§ˆ
            renderNextPiece();
        }

        // æ¶ˆé™¤å·²æ»¡çš„è¡Œ
        function clearLines() {
            let linesClearedThisTime = 0;
            for (let y = GRID_HEIGHT - 1; y >= 0; y--) {
                if (board[y].every(cell => cell !== 0)) {
                    // ç§»é™¤å·²æ»¡çš„è¡Œ
                    board.splice(y, 1);
                    // åœ¨é¡¶éƒ¨æ·»åŠ ä¸€ä¸ªæ–°çš„ç©ºè¡Œ
                    board.unshift(Array(GRID_WIDTH).fill(0));
                    linesClearedThisTime++;
                    y++; // å› ä¸ºåˆ é™¤äº†ä¸€è¡Œï¼Œéœ€è¦é‡æ–°æ£€æŸ¥å½“å‰ç´¢å¼•
                }
            }
            
            if (linesClearedThisTime > 0) {
                // æ›´æ–°åˆ†æ•° (ç»å…¸è®¡åˆ†è§„åˆ™)
                const linePoints = [0, 100, 300, 500, 800]; // 0, 1, 2, 3, 4è¡Œçš„åˆ†æ•°
                score += linePoints[linesClearedThisTime] * level;
                linesCleared += linesClearedThisTime;
                
                // æ›´æ–°ç­‰çº§ (æ¯æ¶ˆé™¤10è¡Œå‡ä¸€çº§)
                const newLevel = Math.floor(linesCleared / 10) + 1;
                if (newLevel > level) {
                    level = newLevel;
                    // åŠ å¿«ä¸‹è½é€Ÿåº¦ï¼Œä½†æœ‰æœ€ä½é™åˆ¶
                    if (dropInterval > 100) {
                        dropInterval -= 100;
                        restartDropTimer();
                    }
                }
                
                // æ›´æ–°æ˜¾ç¤º
                scoreDisplay.textContent = score;
                levelDisplay.textContent = level;
                linesDisplay.textContent = linesCleared;
                
                // å¢åŠ æŠ€èƒ½èƒ½é‡
                addPower(POWER_PER_LINE * linesClearedThisTime);
            }
        }

        // æ¸²æŸ“æ¸¸æˆç”»é¢
        function render() {
            // æ¸…ç©ºç”»å¸ƒ
            ctx.fillStyle = '#1f2937'; // bg-gray-800
            ctx.fillRect(0, 0, gameCanvas.width, gameCanvas.height);
            
            // ç»˜åˆ¶ç½‘æ ¼çº¿
            ctx.strokeStyle = '#374151'; // bg-gray-700
            ctx.lineWidth = 1;
            for (let y = 0; y < GRID_HEIGHT; y++) {
                for (let x = 0; x < GRID_WIDTH; x++) {
                    ctx.strokeRect(x * CELL_SIZE, y * CELL_SIZE, CELL_SIZE, CELL_SIZE);
                }
            }
            
            // ç»˜åˆ¶å·²é”å®šçš„æ–¹å—
            for (let y = 0; y < GRID_HEIGHT; y++) {
                for (let x = 0; x < GRID_WIDTH; x++) {
                    if (board[y][x]) {
                        drawCell(ctx, x, y, board[y][x]);
                    }
                }
            }
            
            // ç»˜åˆ¶å¹½çµæ–¹å—ï¼ˆå¦‚æœå¹½çµæ¨¡å¼æ¿€æ´»ï¼‰
            if (isGhostActive && currentPiece) {
                const ghostPiece = {
                    shape: currentPiece.shape,
                    color: currentPiece.color,
                    x: currentPiece.x,
                    y: currentPiece.y
                };
                
                // è®¡ç®—å¹½çµæ–¹å—æœ€ç»ˆä½ç½®
                while (isValidMove(ghostPiece, 0, 1)) {
                    ghostPiece.y++;
                }
                
                // ç»˜åˆ¶å¹½çµæ–¹å—ï¼ˆåŠé€æ˜ï¼‰
                for (let y = 0; y < ghostPiece.shape.length; y++) {
                    for (let x = 0; x < ghostPiece.shape[y].length; x++) {
                        if (ghostPiece.shape[y][x]) {
                            const boardY = ghostPiece.y + y;
                            const boardX = ghostPiece.x + x;
                            if (boardY >= 0) { // åªç»˜åˆ¶åœ¨æ¸¸æˆåŒºåŸŸå†…çš„éƒ¨åˆ†
                                ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
                                ctx.fillRect(boardX * CELL_SIZE, boardY * CELL_SIZE, CELL_SIZE, CELL_SIZE);
                                ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
                                ctx.lineWidth = 2;
                                ctx.strokeRect(boardX * CELL_SIZE, boardY * CELL_SIZE, CELL_SIZE, CELL_SIZE);
                            }
                        }
                    }
                }
            }
            
            // ç»˜åˆ¶å½“å‰æ–¹å—
            if (currentPiece) {
                for (let y = 0; y < currentPiece.shape.length; y++) {
                    for (let x = 0; x < currentPiece.shape[y].length; x++) {
                        if (currentPiece.shape[y][x]) {
                            const boardY = currentPiece.y + y;
                            const boardX = currentPiece.x + x;
                            if (boardY >= 0) { // åªç»˜åˆ¶åœ¨æ¸¸æˆåŒºåŸŸå†…çš„éƒ¨åˆ†
                                drawCell(ctx, boardX, boardY, currentPiece.color);
                            }
                        }
                    }
                }
            }
            
            // æŠ€èƒ½è§†è§‰æ•ˆæœ
            if (isSlowActive) {
                ctx.fillStyle = 'rgba(59, 130, 246, 0.2)'; // bg-blue-500 with opacity
                ctx.fillRect(0, 0, gameCanvas.width, gameCanvas.height);
            }
            
            if (isGhostActive) {
                ctx.fillStyle = 'rgba(168, 85, 247, 0.1)'; // bg-purple-500 with opacity
                ctx.fillRect(0, 0, gameCanvas.width, gameCanvas.height);
            }
            
            if (isGravityReversed) {
                ctx.fillStyle = 'rgba(236, 72, 153, 0.2)'; // bg-pink-500 with opacity
                ctx.fillRect(0, 0, gameCanvas.width, gameCanvas.height);
            }
        }

        // æ¸²æŸ“ä¸‹ä¸€ä¸ªæ–¹å—é¢„è§ˆ
        function renderNextPiece() {
            // æ¸…ç©ºç”»å¸ƒ
            nextCtx.fillStyle = '#1f2937'; // bg-gray-800
            nextCtx.fillRect(0, 0, nextPieceCanvas.width, nextPieceCanvas.height);
            
            // ç»˜åˆ¶ä¸‹ä¸€ä¸ªæ–¹å—
            if (nextPiece) {
                // è®¡ç®—å±…ä¸­åç§»
                const offsetX = (nextPieceCanvas.width - nextPiece.shape[0].length * CELL_SIZE) / 2;
                const offsetY = (nextPieceCanvas.height - nextPiece.shape.length * CELL_SIZE) / 2;
                
                for (let y = 0; y < nextPiece.shape.length; y++) {
                    for (let x = 0; x < nextPiece.shape[y].length; x++) {
                        if (nextPiece.shape[y][x]) {
                            nextCtx.fillStyle = nextPiece.color;
                            nextCtx.fillRect(
                                offsetX + x * CELL_SIZE, 
                                offsetY + y * CELL_SIZE, 
                                CELL_SIZE, 
                                CELL_SIZE
                            );
                            // è¾¹æ¡†
                            nextCtx.strokeStyle = '#ffffff';
                            nextCtx.lineWidth = 2;
                            nextCtx.strokeRect(
                                offsetX + x * CELL_SIZE, 
                                offsetY + y * CELL_SIZE, 
                                CELL_SIZE, 
                                CELL_SIZE
                            );
                        }
                    }
                }
            }
        }

        // ç»˜åˆ¶å•ä¸ªæ–¹å—
        function drawCell(context, x, y, color) {
            context.fillStyle = color;
            context.fillRect(x * CELL_SIZE, y * CELL_SIZE, CELL_SIZE, CELL_SIZE);
            
            // é«˜å…‰æ•ˆæœï¼Œè®©æ–¹å—æ›´æœ‰ç«‹ä½“æ„Ÿ
            context.fillStyle = 'rgba(255, 255, 255, 0.2)';
            context.fillRect(x * CELL_SIZE, y * CELL_SIZE, CELL_SIZE, CELL_SIZE / 4);
            context.fillRect(x * CELL_SIZE, y * CELL_SIZE, CELL_SIZE / 4, CELL_SIZE);
            
            // è¾¹æ¡†
            context.strokeStyle = '#ffffff';
            context.lineWidth = 2;
            context.strokeRect(x * CELL_SIZE, y * CELL_SIZE, CELL_SIZE, CELL_SIZE);
        }

        // å¤„ç†é”®ç›˜è¾“å…¥
        function handleKeydown(e) {
            if (!isGameRunning) return;

            switch (e.key) {
                // æ–¹å‘é”®æ§åˆ¶
                case 'ArrowLeft':
                case 'a':
                case 'A':
                    if (isValidMove(currentPiece, -1, 0)) {
                        currentPiece.x--;
                    }
                    break;
                case 'ArrowRight':
                case 'd':
                case 'D':
                    if (isValidMove(currentPiece, 1, 0)) {
                        currentPiece.x++;
                    }
                    break;
                case 'ArrowDown':
                case 's':
                case 'S':
                    movePieceDown();
                    break;
                case 'ArrowUp':
                case 'w':
                case 'W':
                    rotatePiece(currentPiece);
                    break;
                case ' ': // ç©ºæ ¼é”®
                    hardDrop();
                    break;
                    
                // æŠ€èƒ½å¿«æ·é”®
                case '1':
                    useSkillBomb();
                    break;
                case '2':
                    useSkillSlow();
                    break;
                case '3':
                    useSkillTransform();
                    break;
                case '4':
                    useSkillLineClear();
                    break;
                case '5':
                    useSkillSmash();
                    break;
                case '6':
                    useSkillGhost();
                    break;
                case '7':
                    useSkillGravity();
                    break;
            }
        }

        // ç§»åŠ¨æ–¹å—ï¼ˆæ ¹æ®é‡åŠ›æ–¹å‘ï¼‰
        function movePieceDown() {
            const direction = isGravityReversed ? -1 : 1;
            if (isValidMove(currentPiece, 0, direction)) {
                currentPiece.y += direction;
                // ç§»åŠ¨å¯ä»¥è·å¾—å°‘é‡åˆ†æ•°
                score++;
                scoreDisplay.textContent = score;
            } else {
                // å¦‚æœé‡åŠ›åè½¬ï¼Œæ£€æŸ¥æ˜¯å¦è§¦é¡¶
                if (isGravityReversed && currentPiece.y <= 0) {
                    lockPiece();
                } 
                // æ­£å¸¸é‡åŠ›ä¸‹è§¦åº•
                else if (!isGravityReversed) {
                    lockPiece();
                }
            }
        }

        // ç¡¬é™è½ (ç›´æ¥è½åˆ°ç›¸åº”æ–¹å‘çš„åº•éƒ¨)
        function hardDrop() {
            const direction = isGravityReversed ? -1 : 1;
            while (isValidMove(currentPiece, 0, direction)) {
                currentPiece.y += direction;
                // ç¡¬é™è½æ¯æ ¼è·å¾—æ›´å¤šåˆ†æ•°
                score += 2;
            }
            scoreDisplay.textContent = score;
            lockPiece();
        }

        // å¼€å§‹æ¸¸æˆ
        function startGame() {
            if (isGameRunning) return;

            // é‡ç½®æ¸¸æˆçŠ¶æ€
            initBoard();
            score = 0;
            level = 1;
            linesCleared = 0;
            dropInterval = 1000;
            
            // é‡ç½®æŠ€èƒ½çŠ¶æ€
            setPower(0);
            skillCharges = 0;
            updateSkillChargesDisplay();
            isSlowActive = false;
            isGhostActive = false;
            isGravityReversed = false;
            
            if (slowTimer) clearTimeout(slowTimer);
            if (ghostTimer) clearTimeout(ghostTimer);
            if (gravityTimer) clearTimeout(gravityTimer);
            
            scoreDisplay.textContent = score;
            levelDisplay.textContent = level;
            linesDisplay.textContent = linesCleared;
            
            // ç”Ÿæˆåˆå§‹æ–¹å—
            currentPiece = generateRandomPiece();
            nextPiece = generateRandomPiece();
            renderNextPiece();
            
            // å¼€å§‹æ¸¸æˆå¾ªç¯
            isGameRunning = true;
            startScreen.classList.add('hidden');
            gameOverScreen.classList.add('hidden');
            
            // æ¸…é™¤ä»»ä½•å¯èƒ½å­˜åœ¨çš„æ—§å¾ªç¯
            if (gameLoopId) clearInterval(gameLoopId);
            gameLoopId = setInterval(gameLoop, 16); // ~60 FPS
            
            restartDropTimer();
        }

        // æ¸¸æˆç»“æŸ
        function gameOver() {
            isGameRunning = false;
            clearInterval(gameLoopId);
            clearInterval(dropTimer);
            if (slowTimer) clearTimeout(slowTimer);
            if (ghostTimer) clearTimeout(ghostTimer);
            if (gravityTimer) clearTimeout(gravityTimer);
            
            // ä¿å­˜æœ€é«˜åˆ†æ•°
            saveHighScore();
            
            finalScoreDisplay.textContent = score;
            gameOverScreen.classList.remove('hidden');
        }

        // æ¸¸æˆä¸»å¾ªç¯
        function gameLoop() {
            render();
        }

        // é‡ç½®ä¸‹è½è®¡æ—¶å™¨
        function restartDropTimer() {
            clearInterval(dropTimer);
            dropTimer = setInterval(() => {
                if (isGameRunning) {
                    movePieceDown();
                }
            }, dropInterval);
        }

        // --- æŠ€èƒ½ç³»ç»Ÿå‡½æ•° ---

        // è®¾ç½®èƒ½é‡å€¼
        function setPower(newPower) {
            power = Math.min(newPower, MAX_POWER);
            const percentage = (power / MAX_POWER) * 100;
            powerBar.style.width = `${percentage}%`;
            powerPercentage.textContent = `${Math.round(percentage)}%`;
            
            // å¦‚æœèƒ½é‡æ»¡äº†ï¼Œå¢åŠ æŠ€èƒ½æ¬¡æ•°
            if (power >= MAX_POWER && skillCharges < MAX_SKILL_CHARGES) {
                skillCharges++;
                updateSkillChargesDisplay();
                setPower(0); // é‡ç½®èƒ½é‡æ¡
            }
            
            // æ ¹æ®æ˜¯å¦æœ‰æŠ€èƒ½æ¬¡æ•°æ¥å¯ç”¨/ç¦ç”¨æŠ€èƒ½æŒ‰é’®
            const areSkillsEnabled = skillCharges > 0;
            skillButtons.forEach(button => {
                button.disabled = !areSkillsEnabled;
            });
        }

        // æ›´æ–°æŠ€èƒ½æ¬¡æ•°æ˜¾ç¤º
        function updateSkillChargesDisplay() {
            skillCountDisplay.textContent = skillCharges;
        }

        // å¢åŠ èƒ½é‡
        function addPower(amount) {
            setPower(power + amount);
        }

        // ä½¿ç”¨æŠ€èƒ½çš„é€šç”¨å‡½æ•°
        function useSkill(skillFunction) {
            if (skillCharges <= 0) return;
            
            skillFunction();
            skillCharges--;
            updateSkillChargesDisplay();
            
            // æ›´æ–°æŠ€èƒ½æŒ‰é’®çŠ¶æ€
            const areSkillsEnabled = skillCharges > 0;
            skillButtons.forEach(button => {
                button.disabled = !areSkillsEnabled;
            });
        }

        // ä½¿ç”¨æŠ€èƒ½ - ç‚¸å¼¹ (æ¸…é™¤æœ€ä¸‹é¢çš„ä¸‰è¡Œ)
        function useSkillBomb() {
            useSkill(() => {
                let linesClearedBySkill = 0;
                // ä»åº•éƒ¨å‘ä¸Šæ£€æŸ¥å¹¶æ¸…é™¤æœ€å¤šä¸‰è¡Œ
                for (let y = GRID_HEIGHT - 1; y >= 0 && linesClearedBySkill < 3; y--) {
                    if (board[y].some(cell => cell !== 0)) { // åªè¦è¡Œä¸­æœ‰æ–¹å—å°±æ¸…é™¤
                        board.splice(y, 1);
                        board.unshift(Array(GRID_WIDTH).fill(0));
                        linesClearedBySkill++;
                    }
                }
                
                if (linesClearedBySkill > 0) {
                    // æ›´æ–°æ¸¸æˆçŠ¶æ€
                    linesCleared += linesClearedBySkill;
                    linesDisplay.textContent = linesCleared;
                    
                    // è®¡ç®—æŠ€èƒ½å¾—åˆ† (æ¯æ¸…é™¤ä¸€è¡Œè·å¾—100åˆ†)
                    const skillScore = linesClearedBySkill * 100;
                    score += skillScore;
                    scoreDisplay.textContent = score;
                    
                    // æ£€æŸ¥ç­‰çº§æå‡
                    const newLevel = Math.floor(linesCleared / 10) + 1;
                    if (newLevel > level) {
                        level = newLevel;
                        if (dropInterval > 100) {
                            dropInterval -= 100;
                            restartDropTimer();
                        }
                        levelDisplay.textContent = level;
                    }
                }
                
                // æ’­æ”¾ä¸€ä¸ªç®€å•çš„è§†è§‰æ•ˆæœ (é—ªçƒ)
                let flashCount = 0;
                const flashInterval = setInterval(() => {
                    gameCanvas.style.opacity = flashCount % 2 === 0 ? '0.5' : '1';
                    flashCount++;
                    if (flashCount > 6) {
                        clearInterval(flashInterval);
                        gameCanvas.style.opacity = '1';
                    }
                }, 150);
            });
        }

        // ä½¿ç”¨æŠ€èƒ½ - å‡é€Ÿ
        function useSkillSlow() {
            useSkill(() => {
                if (isSlowActive) return;
                
                isSlowActive = true;
                const originalDropInterval = dropInterval;
                dropInterval *= 2; // é€Ÿåº¦å‡åŠ
                restartDropTimer();
                
                // 10ç§’åæ¢å¤
                slowTimer = setTimeout(() => {
                    isSlowActive = false;
                    dropInterval = originalDropInterval;
                    restartDropTimer();
                }, 10000);
            });
        }

        // ä½¿ç”¨æŠ€èƒ½ - å˜æ¢
        function useSkillTransform() {
            useSkill(() => {
                // ä¿å­˜å½“å‰æ–¹å—çš„ä½ç½®
                const currentX = currentPiece.x;
                const currentY = currentPiece.y;
                
                // ä¿å­˜å½“å‰å½¢çŠ¶çš„å¼•ç”¨ï¼Œä»¥ä¾¿åœ¨éœ€è¦æ—¶æ¢å¤
                const originalShape = currentPiece.shape;
                const originalColor = currentPiece.color;
                
                // å°è¯•ç”Ÿæˆæ–°å½¢çŠ¶ï¼Œæœ€å¤šå°è¯•5æ¬¡ä»¥æ‰¾åˆ°ä¸€ä¸ªå¯ä»¥æ”¾ç½®çš„å½¢çŠ¶
                let success = false;
                for (let attempt = 0; attempt < 5; attempt++) {
                    const randomIndex = Math.floor(Math.random() * SHAPES.length);
                    const newShapeData = SHAPES[randomIndex];
                    
                    currentPiece.shape = JSON.parse(JSON.stringify(newShapeData.shape));
                    currentPiece.color = newShapeData.color;
                    
                    // å°è¯•è°ƒæ•´ä½ç½®ä»¥é€‚åº”æ–°å½¢çŠ¶
                    if (isValidMove(currentPiece, 0, 0)) {
                        success = true;
                        break;
                    }
                    // å°è¯•å‘å·¦ç§»åŠ¨
                    else if (isValidMove(currentPiece, -1, 0)) {
                        currentPiece.x--;
                        success = true;
                        break;
                    }
                    // å°è¯•å‘å³ç§»åŠ¨
                    else if (isValidMove(currentPiece, 1, 0)) {
                        currentPiece.x++;
                        success = true;
                        break;
                    }
                }
                
                // å¦‚æœæ‰€æœ‰å°è¯•éƒ½å¤±è´¥ï¼Œåˆ™æ¢å¤åŸå§‹å½¢çŠ¶
                if (!success) {
                    currentPiece.shape = originalShape;
                    currentPiece.color = originalColor;
                }
            });
        }

        // ä½¿ç”¨æŠ€èƒ½ - æ°´å¹³æ¶ˆé™¤ (æ¸…é™¤å½“å‰æ–¹å—æ‰€åœ¨çš„ä¸€è¡Œ)
        function useSkillLineClear() {
            useSkill(() => {
                // è·å–å½“å‰æ–¹å—æœ€åº•éƒ¨çš„è¡Œ
                const targetY = isGravityReversed ? 
                    currentPiece.y : 
                    currentPiece.y + currentPiece.shape.length - 1;
                
                // æ£€æŸ¥è¯¥è¡Œæ˜¯å¦åœ¨æ¸¸æˆåŒºåŸŸå†…
                if (targetY >= 0 && targetY < GRID_HEIGHT) {
                    // æ£€æŸ¥è¯¥è¡Œæ˜¯å¦æœ‰æ–¹å—
                    if (board[targetY].some(cell => cell !== 0)) {
                        // æ¸…é™¤è¯¥è¡Œ
                        board.splice(targetY, 1);
                        board.unshift(Array(GRID_WIDTH).fill(0));
                        
                        // æ›´æ–°æ¸¸æˆçŠ¶æ€
                        linesCleared++;
                        linesDisplay.textContent = linesCleared;
                        
                        // å¢åŠ åˆ†æ•°
                        score += 150; // æ°´å¹³æ¶ˆé™¤æŠ€èƒ½è·å¾—150åˆ†
                        scoreDisplay.textContent = score;
                        
                        // æ£€æŸ¥ç­‰çº§æå‡
                        const newLevel = Math.floor(linesCleared / 10) + 1;
                        if (newLevel > level) {
                            level = newLevel;
                            if (dropInterval > 100) {
                                dropInterval -= 100;
                                restartDropTimer();
                            }
                            levelDisplay.textContent = level;
                        }
                    }
                }
                
                // æ’­æ”¾è§†è§‰æ•ˆæœ
                const originalColor = gameCanvas.style.backgroundColor;
                gameCanvas.style.backgroundColor = 'rgba(0, 255, 0, 0.2)';
                setTimeout(() => {
                    gameCanvas.style.backgroundColor = originalColor;
                }, 300);
            });
        }

        // ä½¿ç”¨æŠ€èƒ½ - ç²‰ç¢ (éšæœºæ¸…é™¤12ä¸ªæ–¹å—)
        function useSkillSmash() {
            useSkill(() => {
                let blocksSmashed = 0;
                const MAX_SMASH_COUNT = 12;
                
                // æ”¶é›†æ‰€æœ‰éç©ºæ–¹å—çš„ä½ç½®
                const filledCells = [];
                for (let y = 0; y < GRID_HEIGHT; y++) {
                    for (let x = 0; x < GRID_WIDTH; x++) {
                        if (board[y][x]) {
                            filledCells.push({x, y});
                        }
                    }
                }
                
                // å¦‚æœæœ‰è¶³å¤Ÿçš„æ–¹å—å¯ä»¥ç²‰ç¢
                if (filledCells.length > 0) {
                    // è®¡ç®—å®é™…å¯ä»¥ç²‰ç¢çš„æ•°é‡ (ä¸è¶…è¿‡MAX_SMASH_COUNT)
                    const smashCount = Math.min(MAX_SMASH_COUNT, filledCells.length);
                    
                    // éšæœºé€‰æ‹©æ–¹å—è¿›è¡Œç²‰ç¢
                    for (let i = 0; i < smashCount; i++) {
                        const randomIndex = Math.floor(Math.random() * filledCells.length);
                        const cell = filledCells.splice(randomIndex, 1)[0];
                        board[cell.y][cell.x] = 0;
                        blocksSmashed++;
                    }
                    
                    // ç»™äºˆç²‰ç¢å¥–åŠ±åˆ†æ•°
                    score += blocksSmashed * 50; // æ¯ä¸ªç²‰ç¢çš„æ–¹å—è·å¾—50åˆ†
                    scoreDisplay.textContent = score;
                }
                
                // æ’­æ”¾è§†è§‰æ•ˆæœ
                let flashCount = 0;
                const flashInterval = setInterval(() => {
                    gameCanvas.style.opacity = flashCount % 2 === 0 ? '0.7' : '1';
                    flashCount++;
                    if (flashCount > 8) {
                        clearInterval(flashInterval);
                        gameCanvas.style.opacity = '1';
                    }
                }, 100);
            });
        }

        // ä½¿ç”¨æŠ€èƒ½ - å¹½çµæ¨¡å¼ (æ˜¾ç¤ºæ–¹å—è½ç‚¹é¢„è§ˆ)
        function useSkillGhost() {
            useSkill(() => {
                if (isGhostActive) return;
                
                isGhostActive = true;
                
                // 5ç§’åæ¢å¤
                ghostTimer = setTimeout(() => {
                    isGhostActive = false;
                }, 5000);
            });
        }

        // ä½¿ç”¨æŠ€èƒ½ - é‡åŠ›åè½¬ (æ–¹å—å‘ä¸Šç§»åŠ¨)
        function useSkillGravity() {
            useSkill(() => {
                if (isGravityReversed) return;
                
                isGravityReversed = true;
                
                // 5ç§’åæ¢å¤
                gravityTimer = setTimeout(() => {
                    isGravityReversed = false;
                }, 5000);
            });
        }

        // äº‹ä»¶ç›‘å¬
        document.addEventListener('keydown', handleKeydown);
        startButton.addEventListener('click', startGame);
        restartButton.addEventListener('click', startGame);
        
        // æŠ€èƒ½æŒ‰é’®äº‹ä»¶ç›‘å¬
        skillBombButton.addEventListener('click', useSkillBomb);
        skillSlowButton.addEventListener('click', useSkillSlow);
        skillTransformButton.addEventListener('click', useSkillTransform);
        skillLineClearButton.addEventListener('click', useSkillLineClear);
        skillSmashButton.addEventListener('click', useSkillSmash);
        skillGhostButton.addEventListener('click', useSkillGhost);
        skillGravityButton.addEventListener('click', useSkillGravity);

        // åˆå§‹åŒ–æ¸¸æˆ
        initBoard();
        updateHighScoreDisplay();
        // é¢„å…ˆæ¸²æŸ“å¼€å§‹ç•Œé¢
        render();
    </script>
</body>
</html>

